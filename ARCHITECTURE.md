# Architecture

This document describes the technical architecture and design decisions for Kumo Budget.

## Design Principles

### 1. Never Access DB Directly

All database operations go through Drizzle ORM and the query layer. Routes should never call `db.select()`, `db.insert()`, etc. directly.

```
Route → Auth/Service → Query Layer → Drizzle ORM → D1
```

This ensures:

- Consistent data access patterns
- Easier testing and mocking
- Type safety throughout the stack
- Centralized query optimization

### 2. Type Safety

Full TypeScript with strict mode enabled. Types are inferred from the Drizzle schema, ensuring database types flow through to the UI.

### 3. Configurable

All tunables are centralized in `app/lib/config.ts` and can be overridden via environment variables. No magic numbers in code.

### 4. Separation of Concerns

Clear layers with single responsibilities:

- **Routes**: Handle HTTP, call services, render UI
- **Services/Auth**: Business logic, orchestration
- **Queries**: Database operations only
- **Config**: Environment and settings

## Database Layer

### Schema (`app/lib/db/schema.ts`)

The schema file is the single source of truth for database structure. Drizzle Kit generates migrations from this file.

```typescript
// Example: Users table
export const users = sqliteTable('users', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  username: text('username').notNull().unique(),
  passwordHash: text('password_hash').notNull(),
  // ...
});
```

**Key points:**

- Use `sqliteTable` for D1 (SQLite-based)
- Define relations in the same file
- Export TypeScript types for use in app

### Query Layer (`app/lib/db/queries/`)

Each entity has its own query file with all database operations:

```typescript
// users.ts
export const userQueries = {
  findByUsername: async (db: Database, username: string) => { ... },
  create: async (db: Database, data: NewUser) => { ... },
  exists: async (db: Database, username: string) => { ... },
};
```

**Benefits:**

- Easy to test (mock the query object)
- Discoverable (all user queries in one place)
- Consistent patterns across entities

### Migrations

Migrations are generated by Drizzle Kit and applied via Wrangler:

```bash
# Generate migration from schema changes
npm run db:generate

# Apply locally
npm run db:migrate

# Apply to production
npm run db:migrate:prod
```

**Never edit migrations manually** - they are auto-generated from the schema.

## Authentication

### Password Hashing

Uses bcrypt with configurable rounds (default: 10). Passwords are never stored in plain text.

```typescript
// Hash on registration/seed
const hash = await hashPassword(password);

// Verify on login
const isValid = await verifyPassword(password, user.passwordHash);
```

### Session Management

Sessions are stored in D1 with expiration timestamps. On each request:

1. Extract session ID from cookie
2. Look up session in D1
3. Check expiration
4. Return user if valid, redirect if not

```typescript
// In a protected route loader:
export async function loader({ request, context }: Route.LoaderArgs) {
  const { user } = await requireAuth(request, context.cloudflare.env);
  return { user };
}
```

### Cookie Security

Session cookies use secure defaults:

- `HttpOnly` - No JavaScript access
- `Secure` - HTTPS only
- `SameSite=Lax` - CSRF protection
- `Max-Age` - Matches session duration

## UI Layer

### Kumo Components

[Kumo](https://kumo-ui.com) is Cloudflare's official React component library. It provides consistent, accessible UI components.

```typescript
import { Button, Input, Surface, Text } from '@cloudflare/kumo';
```

**Setup Requirements:**

1. Import Kumo styles before Tailwind in CSS
2. Add `@source` directive for Kumo's Tailwind classes
3. Use `LinkProvider` if using client-side routing (not needed with React Router)

### Styling

Tailwind CSS 4 with Kumo's design tokens. Custom styles go in `app.css`:

```css
@source "../node_modules/@cloudflare/kumo/dist/**/*.{js,jsx,ts,tsx}";
@import '@cloudflare/kumo/styles/tailwind';
@import 'tailwindcss' source('.');
```

## File Organization

```
app/
├── routes/          # Pages (React Router file-based routing)
├── components/      # Shared UI components
└── lib/             # Business logic & utilities
    ├── db/          # Database layer
    │   ├── schema.ts    # Table definitions
    │   ├── index.ts     # Client factory
    │   └── queries/     # Query functions
    ├── auth/        # Authentication
    │   ├── password.ts  # Hashing utilities
    │   ├── session.ts   # Session management
    │   ├── middleware.ts# Route protection
    │   └── index.ts     # Barrel export
    └── config.ts    # Configuration
```

## Error Handling

### Database Errors

Drizzle throws on constraint violations. Catch and return user-friendly errors:

```typescript
try {
  await userQueries.create(db, data);
} catch (error) {
  if (error.message.includes('UNIQUE constraint failed')) {
    return { error: 'Username already exists' };
  }
  throw error;
}
```

### Auth Errors

Auth middleware throws redirects. Use React Router's `redirect()`:

```typescript
if (!session) {
  throw redirect('/login');
}
```

### UI Errors

Use React Router's error boundary in `root.tsx` for unexpected errors.

## Security Considerations

### Password Storage

- Bcrypt with 10+ rounds
- Never log or expose hashes
- Use constant-time comparison (bcrypt.compare)

### Session Security

- Random UUID session IDs
- Server-side expiration validation
- Session destroyed on logout
- Consider adding: IP binding, user agent tracking

### Input Validation

- Validate all form inputs server-side
- Use TypeScript to ensure type safety
- Sanitize before database operations

### CSRF Protection

- `SameSite=Lax` cookies
- Form submissions use POST
- Consider adding CSRF tokens for sensitive operations

## Performance

### Database

- D1 queries are fast (edge SQLite)
- Use indexes for frequently queried columns
- Keep session lookups efficient

### Caching

Currently no caching. Consider adding:

- Session cache (short TTL)
- Static asset caching headers
- React Router data caching

### Bundle Size

- Kumo is tree-shakeable
- Use granular imports when possible
- Lazy load routes if app grows

## Testing

### Unit Tests

Test query functions in isolation:

```typescript
// Mock the database
const mockDb = { query: { users: { findFirst: vi.fn() } } };
await userQueries.findByUsername(mockDb, 'test');
```

### Integration Tests

Test auth flows with real D1 (local):

```bash
# Run dev server with local D1
npm run dev

# Test login flow
curl -X POST http://localhost:5173/login -d "username=admin&password=admin"
```

## Projects Feature

### Overview

Projects are the core organizational unit in Kumo Budget. Users can create projects, invite collaborators, and organize work into nested hierarchies.

### Data Model

```
projects
├── id (PK)
├── name
├── parent_id (FK → projects.id, nullable)
├── created_at
└── updated_at

project_members
├── project_id (FK → projects.id)
├── user_id (FK → users.id)
├── role (owner | editor | viewer)
└── joined_at
```

**Key constraints:**

- `parent_id` enables unlimited nesting (self-referential)
- Deleting a project cascades to all children and members
- Every project must have at least one owner

### Role-Based Access Control

Three roles with hierarchical permissions:

| Role   | View | Edit | Manage Members | Delete |
| ------ | ---- | ---- | -------------- | ------ |
| viewer | ✓    |      |                |        |
| editor | ✓    | ✓    |                |        |
| owner  | ✓    | ✓    | ✓              | ✓      |

**Implementation:**

```typescript
// Check user has required role
const { role } = await requireProjectAccess(db, userId, projectId, 'editor');

// Helper functions
canEdit(role); // editor or owner
isOwner(role); // owner only
```

### Project Hierarchy

Projects support unlimited nesting:

```
Home Budget (owner)
├── Monthly Expenses (editor)
│   ├── Groceries
│   └── Utilities
└── Savings Goals
    ├── Emergency Fund
    └── Vacation
```

**Query patterns:**

```typescript
// Get immediate children
await projectQueries.findChildren(db, projectId);

// Get all ancestors (for breadcrumbs)
await projectQueries.findAncestors(db, projectId);
```

### Routes

| Route                    | Purpose                                |
| ------------------------ | -------------------------------------- |
| `/projects`              | List user's projects                   |
| `/projects/new`          | Create new project                     |
| `/projects/:id`          | Project detail (sub-projects, members) |
| `/projects/:id/new`      | Create sub-project                     |
| `/projects/:id/settings` | Manage members, delete project         |

### Authorization Middleware

Protected routes use `requireProjectAccess`:

```typescript
export async function loader({ request, context, params }: Route.LoaderArgs) {
  const { user } = await requireAuth(request, context.cloudflare.env);
  const db = createDb(context.cloudflare.env.DB);

  // Throws 403 if user doesn't have required role
  const { role } = await requireProjectAccess(db, user.id, projectId, 'viewer');

  // ...
}
```

### Cascade Delete

When a project is deleted:

1. All child projects are deleted (recursive)
2. All project_members entries are removed
3. Parent project is unaffected

This is handled by SQLite foreign key constraints with `ON DELETE CASCADE`.

## UI Guidelines

### Color Usage

**DO use neutral colors only:**

- `text-neutral-*` for text
- `bg-neutral-*` for backgrounds
- `border-neutral-*` for borders

**DO NOT use semantic colors:**

- No `text-red-*`, `bg-red-*` etc.
- No `text-blue-*`, `bg-blue-*` etc.
- No `text-green-*`, `bg-green-*` etc.

Kumo's `Text variant="error"` handles error text color. For containers, use neutral backgrounds.

### Kumo Component Guidelines

**Text component:**

- Use `variant` for semantic styling (heading1, heading2, heading3, body, secondary, error)
- Use `size` for sizing (xs, sm, base, lg) - NOT xl/2xl
- Use `bold` boolean - NOT weight prop
- Do NOT use `className` - wrap in div if spacing needed

**Button component:**

- Variants: "primary", "secondary", "ghost", "destructive"
- NOT "danger" (use "destructive")

**Surface component:**

- Can accept `className` for styling

### Light Mode Only

The app uses light mode exclusively. Do not use `dark:` Tailwind variants.

## Future Considerations

### Feature Ideas

- User registration
- Password reset
- Remember me checkbox
- Session listing/revocation
- Rate limiting on login
- Project archiving (soft delete)
- Project templates
- Activity log per project

### Infrastructure

- Add R2 usage for file storage
- Consider Durable Objects for real-time features
- Add Workers Analytics
- Set up CI/CD with GitHub Actions
