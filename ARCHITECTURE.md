# Architecture

This document describes the technical architecture and design decisions for Kumo Budget.

## Design Principles

### 1. Never Access DB Directly

All database operations go through Drizzle ORM and the query layer. Routes should never call `db.select()`, `db.insert()`, etc. directly.

```
Route → Auth/Service → Query Layer → Drizzle ORM → D1
```

This ensures:

- Consistent data access patterns
- Easier testing and mocking
- Type safety throughout the stack
- Centralized query optimization

### 2. Type Safety

Full TypeScript with strict mode enabled. Types are inferred from the Drizzle schema, ensuring database types flow through to the UI.

### 3. Configurable

All tunables are centralized in `app/lib/config.ts` and can be overridden via environment variables. No magic numbers in code.

### 4. Separation of Concerns

Clear layers with single responsibilities:

- **Routes**: Handle HTTP, call services, render UI
- **Services/Auth**: Business logic, orchestration
- **Queries**: Database operations only
- **Config**: Environment and settings

## Database Layer

### Schema (`app/lib/db/schema.ts`)

The schema file is the single source of truth for database structure. Drizzle Kit generates migrations from this file.

```typescript
// Example: Users table
export const users = sqliteTable('users', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  username: text('username').notNull().unique(),
  passwordHash: text('password_hash').notNull(),
  // ...
});
```

**Key points:**

- Use `sqliteTable` for D1 (SQLite-based)
- Define relations in the same file
- Export TypeScript types for use in app

### Query Layer (`app/lib/db/queries/`)

Each entity has its own query file with all database operations:

```typescript
// users.ts
export const userQueries = {
  findByUsername: async (db: Database, username: string) => { ... },
  create: async (db: Database, data: NewUser) => { ... },
  exists: async (db: Database, username: string) => { ... },
};
```

**Benefits:**

- Easy to test (mock the query object)
- Discoverable (all user queries in one place)
- Consistent patterns across entities

### Migrations

Migrations are generated by Drizzle Kit and applied via Wrangler:

```bash
# Generate migration from schema changes
npm run db:generate

# Apply locally
npm run db:migrate

# Apply to production
npm run db:migrate:prod
```

**Never edit migrations manually** - they are auto-generated from the schema.

## Authentication

### Password Hashing

Uses bcrypt with configurable rounds (default: 10). Passwords are never stored in plain text.

```typescript
// Hash on registration/seed
const hash = await hashPassword(password);

// Verify on login
const isValid = await verifyPassword(password, user.passwordHash);
```

### Session Management

Sessions are stored in D1 with expiration timestamps. On each request:

1. Extract session ID from cookie
2. Look up session in D1
3. Check expiration
4. Return user if valid, redirect if not

```typescript
// In a protected route loader:
export async function loader({ request, context }: Route.LoaderArgs) {
  const { user } = await requireAuth(request, context.cloudflare.env);
  return { user };
}
```

### Cookie Security

Session cookies use secure defaults:

- `HttpOnly` - No JavaScript access
- `Secure` - HTTPS only
- `SameSite=Lax` - CSRF protection
- `Max-Age` - Matches session duration

## UI Layer

### Kumo Components

[Kumo](https://kumo-ui.com) is Cloudflare's official React component library. It provides consistent, accessible UI components.

```typescript
import { Button, Input, Surface, Text } from '@cloudflare/kumo';
```

**Setup Requirements:**

1. Import Kumo styles before Tailwind in CSS
2. Add `@source` directive for Kumo's Tailwind classes
3. Use `LinkProvider` if using client-side routing (not needed with React Router)

### Styling

Tailwind CSS 4 with Kumo's design tokens. Custom styles go in `app.css`:

```css
@source "../node_modules/@cloudflare/kumo/dist/**/*.{js,jsx,ts,tsx}";
@import '@cloudflare/kumo/styles/tailwind';
@import 'tailwindcss' source('.');
```

## File Organization

```
app/
├── routes/          # Pages (React Router file-based routing)
├── components/      # Shared UI components
└── lib/             # Business logic & utilities
    ├── db/          # Database layer
    │   ├── schema.ts    # Table definitions
    │   ├── index.ts     # Client factory
    │   └── queries/     # Query functions
    ├── auth/        # Authentication
    │   ├── password.ts  # Hashing utilities
    │   ├── session.ts   # Session management
    │   ├── middleware.ts# Route protection
    │   └── index.ts     # Barrel export
    └── config.ts    # Configuration
```

## Error Handling

### Database Errors

Drizzle throws on constraint violations. Catch and return user-friendly errors:

```typescript
try {
  await userQueries.create(db, data);
} catch (error) {
  if (error.message.includes('UNIQUE constraint failed')) {
    return { error: 'Username already exists' };
  }
  throw error;
}
```

### Auth Errors

Auth middleware throws redirects. Use React Router's `redirect()`:

```typescript
if (!session) {
  throw redirect('/login');
}
```

### UI Errors

Use React Router's error boundary in `root.tsx` for unexpected errors.

## Security Considerations

### Password Storage

- Bcrypt with 10+ rounds
- Never log or expose hashes
- Use constant-time comparison (bcrypt.compare)

### Session Security

- Random UUID session IDs
- Server-side expiration validation
- Session destroyed on logout
- Consider adding: IP binding, user agent tracking

### Input Validation

- Validate all form inputs server-side
- Use TypeScript to ensure type safety
- Sanitize before database operations

### CSRF Protection

- `SameSite=Lax` cookies
- Form submissions use POST
- Consider adding CSRF tokens for sensitive operations

## Performance

### Database

- D1 queries are fast (edge SQLite)
- Use indexes for frequently queried columns
- Keep session lookups efficient

### Caching

Currently no caching. Consider adding:

- Session cache (short TTL)
- Static asset caching headers
- React Router data caching

### Bundle Size

- Kumo is tree-shakeable
- Use granular imports when possible
- Lazy load routes if app grows

## Testing

### Unit Tests

Test query functions in isolation:

```typescript
// Mock the database
const mockDb = { query: { users: { findFirst: vi.fn() } } };
await userQueries.findByUsername(mockDb, 'test');
```

### Integration Tests

Test auth flows with real D1 (local):

```bash
# Run dev server with local D1
npm run dev

# Test login flow
curl -X POST http://localhost:5173/login -d "username=admin&password=admin"
```

## Future Considerations

### Feature Ideas

- User registration
- Password reset
- Remember me checkbox
- Session listing/revocation
- Rate limiting on login

### Infrastructure

- Add R2 usage for file storage
- Consider Durable Objects for real-time features
- Add Workers Analytics
- Set up CI/CD with GitHub Actions
